#!/usr/bin/python

import argparse
import time
import re
import platform
from socket import gethostname
import os
import subprocess
import ConfigParser as configparser
import abc

argparser = argparse.ArgumentParser();
argparser.add_argument("-n", "--newBuild", action = 'store_true');
argparser.add_argument("--format", "-f", default = "ini", choices = ["ini", "json"]);
argparser.add_argument("--platform", default = None)
argparser.add_argument("--incrementMajor", action = 'store_true')
argparser.add_argument("--incrementMinor", action = 'store_true')
argparser.add_argument("-d", "--debug", action = 'store_true')
argparser.add_argument("-k", "--key", help = "print the value of just one key")
argparser.add_argument("-K", "--keySearch", help = "print the values where the key matches this search term")
argparser.add_argument("-w", "--filename", default = ".buildid")
argparser.add_argument("-q", "--quiet", action = 'store_true')
argparser.add_argument("-p", "--plain", action = "store_true")
args = argparser.parse_args()

configDefaults = {
	"title": "Untitled Project"
}

cfgparser = configparser.ConfigParser(defaults = configDefaults)
cfgparser.add_section("project")
cfgparser.read("buildid.cfg");

def parseConfigVersionWriter(section, cfgparser):
	translator = cfgparser.get(section, "translator")

	writerConfig = dict()
	
	for cfg in cfgparser.items(section):
		writerConfig[cfg[0]] = cfg[1]

	if translator == "PlainFile":
		return VersionTranslatorPlainFile(writerConfig)

class VersionReader():
	def name(self):
		return self.__class__.__name__

	def isUsable(self):
		return True

	@abc.abstractmethod
	def read(self):
		pass

class VersionWriter():
	@abc.abstractmethod
	def write():
		pass

class VersionTranslatorPlainFile(VersionReader, VersionWriter):
	def __init__(self, config = None):
		pass
#		print config

	def read(self):
		version = {
			"major": 0,
			"minor": 0,
			"revision": 0,
			"release": ''
		}

		try:
			versionFile = open('VERSION', 'r')
			content = versionFile.read()
			versionFile.close()

			m = re.search("(\d).(\d).(\d)-?(.+?)", content)

			if m != None:
				version['major'] = int(m.group(1))
				version['minor'] = int(m.group(2))
				version['revision'] = int(m.group(3))
				version['release'] = m.group(4)
			elif args.debug:
				print("VERSION file did not match regex.")
		except IOError as e:
			pass
		except Exception as e:
			print(e)

		return version

	def write():
		f = open("VERSION", "w")
		f.write(getVersionFormattedGnu(version))
		f.close()

versionReaders = [ VersionTranslatorPlainFile() ]
versionWriters = [ VersionTranslatorPlainFile() ]

def printWarning(message):
	printPrefix("WARN", message, 3)

def printInfo(message):
	printPrefix("INFO", message, 4)

def printPrefix(prefix, message, color = None):
	color = ""

	if args.plain:
		endColor = ""
	else:
		endColor = ""

	print("[" + color + prefix + endColor + "] " + message);

class BuildIdFileHandler:
	def getFilename(self):
		if args.filename == ".buildid":
			return self.getDefaultFilename()
		else:
			return args.filename

	def getDefaultFilename(self):
		return args.filename
	
	def fileExists(self):
		return os.path.exists(self.getFilename())

	def toString(self):
		raise NotImplementedError()

	def read(self):
		pass
		#raise NotImplementedError()

	def write(self, properties):
		handle = open(self.getFilename(), "w");
		handle.write(self.toString());
		handle.close()

class BuildIdFileHandlerIni(BuildIdFileHandler):
	def getDefaultFilename(self):
		return ".buildid.ini"

	def toString(self):
		buf = ""
		for key in sorted(properties):
			buf += self.toStringSingle(key) + "\n"

		return buf.strip()

	def toStringSingle(self, key):
		return (key + "=" + str(properties[key]))


	def read(self):
		properties = dict()

		content = open(self.getFilename(), 'r').readlines()

		for line in content:
			key, value = line.strip().split("=");
			
			properties[key] = value

		return properties

fileHandlers = {
	"ini": BuildIdFileHandlerIni(),
}

def getVersionFromReaders():
	for reader in versionReaders:
		if reader.isUsable():
			versionFromReader = reader.read()

			printInfo("Reading version using: " + reader.name() + " = " + getVersionFormattedGnu(versionFromReader))

			return versionFromReader # first one only at the mo

def runCommand(cmd):
	output = subprocess.Popen(cmd.split(" "), stdout=subprocess.PIPE).communicate()[0]
	output = output.strip().decode("utf-8")
	return output

def checkGitIgnore():
	if not os.path.exists(".gitignore"):
		return 

	gitIgnoreFile = open(".gitignore", 'r');

	content = gitIgnoreFile.read()

	if "buildid" not in content:
		printWarning("You should ignore your buildid in .gitignore.")

	gitIgnoreFile.close()


def isGit():
	checkGitIgnore();
		
	return os.path.exists(".git")

def getGitRevision():
	return runCommand("git rev-parse HEAD")

def isEmpty(value):
	if value == None:
		return True

	if value == 0:
		return True

	if value == '':
		return True

	return False

def getVersionFormattedShort(version):
	return str(version['major']) + "." + str(version["minor"]) + "." + str(version['revision'])

def getVersionFormattedGnu(version):
	if isEmpty(version['release']):
		rel = ''
	else:
		rel = '-' + str(version['release'])

	return str(version['major']) + "." + str(version["minor"]) + "." + str(version['revision']) + rel

def getVersionFormattedWin(version):
	if isEmpty(version['release']):
		rel = '.0';
	else:
		rel = '.' + str(version['release'])

	return str(version['major']) + "." + str(version["minor"]) + "." + str(version['revision']) + rel

def getPlatform():
	if args.platform != None:
		return args.platform
	else:
		return "linux"

def getVersionFormattedPlatform():
	return getVersionFormattedGnu(version)

def getCommitTag():
	if isGit():
		return getGitRevision()
	else:
		return '00000'

def isReleaseBuild():
	return False

def getSourceTag():
	if isReleaseBuild() and isEverythingCommited():
		return getCommitTag()
	else:
		return properties['timestamp']

def getPackageTag():
	return getVersionFormattedPlatform() + "-" + getSourceTag()

def isEverythingCommited():
	return False

def saveVersion():
	for writer in versionWriters:
		writer.write(getVersionFormattedGnu(version))

def buildProperties():
	properties["timestamp"] = str(int(time.time()))

	properties["version.major"] = version['major']
	properties["version.minor"] = version['minor']
	properties["version.release"] = version['release']
	properties["version.revision"] = version['revision']
	properties["version.formatted.gnu"] = getVersionFormattedGnu(version)
	properties["version.formatted.short"] = getVersionFormattedShort(version)
	properties["version.formatted.win"] = getVersionFormattedWin(version)
	properties["tag"] = getPackageTag()
	properties["buildhost.platform"] = platform.platform()
	properties["buildhost.system"] = platform.system()
	properties["buildhost.release"] = platform.release()
	properties["buildhost.version"] = platform.version()
	properties["buildhost.hostname"] = gethostname()

	if isGit():
		properties["git.revision"] = getGitRevision();
		properties["git.revision.short"] = getGitRevision()[0:7];

	properties["project.title"] = cfgparser.get("project", "title")

	return properties

################################################################################

for section in cfgparser.sections():
	if cfgparser.has_option(section, "type"):
		typeOfThing = cfgparser.get(section, "type")

		if typeOfThing == "writer":
			writer = parseConfigVersionWriter(section, cfgparser)

			versionWriters.append(writer)

		if typeOfThing == "reader":
			reader = parseConfigVersionReader(section, cfgparser)

			versionReaders.append(reader)

if args.incrementMajor:
	version['major'] = version['major'] + 1
	saveVersion()

if args.incrementMinor:
	version['minor'] = version['minor'] + 1
	saveVersion()

properties = dict()
handler = fileHandlers[args.format]

if args.newBuild:
	version = getVersionFromReaders()

	handler.write(buildProperties());

	printInfo("Wrote file: " + handler.getFilename() + ". View the file or jst run `buildid` again to see all the properties.");

else:
	if not handler.fileExists():
		printInfo("There is no buildid file. Use -n to create a new build.")
	else:
		properties = handler.read()

		if args.key:
			if args.key in properties:
				print(properties[args.key])
			else: 
				print(args.key + " was not found.");
		elif args.keySearch:
			for key in properties:
				if args.keySearch in key:
					print(handler.toStringSingle(key))
		else:
			if not args.quiet:
				printInfo("Printing buildid from file: " + handler.getFilename())
				printInfo("You can output a single property with -k <property-name>")
				printInfo("or see all these properties again without this message with -q");
				print("")

			print(handler.toString())
